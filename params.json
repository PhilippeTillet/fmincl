{"name":"Umintl","tagline":"Generic unconstrained optimization framework. Supports custom linear-algebra backends, as well as custom directions/stopping criterions","body":"UMinTL\r\n======\r\n\r\nThis project is a generic unconstrained minimization library relying heavily on template metaprogramming.\r\n\r\n#Features\r\n\r\n* Use **any** Linear Algebra backend\r\n\r\nThe linear algebra routines are well separated from the algorithm implementations.\r\nYou can pass a custom backend in the optimization procedure. This backend should just include a few typedefs, linear algebra routine and procedures to allocate/delete a Vector/Matrix.\r\nFor now, cblas and ViennaCL are available, for using either CPU or OpenCL in the optimization procedure and the objective function.\r\n\r\n* Multiple procedures available\r\n\r\nThe library supports BFGS, L-BFGS, and Nonlinear Conjugate Gradient. Several updates and restart procedures are available for the conjugate gradient method.\r\nThe line-search is done using the strong wolfe-powell conditions.\r\n\r\n* Extend the library yourself\r\n\r\nUMinTL relies on template. You may therefore write your own stopping criterion (eg a cross-validation error if you're doing machine learning). More experienced user may also write their own restarting condition for the conjugate gradient, or their own update direction.\r\n\r\n* A clear interface\r\n\r\nUMinTL provides a clear API, where any functor can be passed to the optimization algorithm. The cumbersomeness of the templates is softened using type-erasure mechanism.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}